var searchIndex = {};
searchIndex['netaddr'] = {"items":[[0,"","netaddr",""],[0,"addr","","Provide operations over IP addresses."],[2,"IpAddr","netaddr::addr","Describe an IP address"],[12,"Ipv4Addr","","",0],[12,"Ipv6Addr","","",0],[2,"IpAddrVersion","","Describe the version of an IP address."],[12,"Ipv4","","",1],[12,"Ipv6","","",1],[0,"ipv4","","Provide operations over IPv4 addresses."],[1,"IpAddr","netaddr::addr::ipv4",""],[18,"MAX_PREFIXLEN","",""],[10,"decode","","",2],[10,"encode","","",2],[10,"hash","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"fmt","","",2],[10,"clone","","",2],[10,"version","","Get the corresponding IP address version.",2],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",2],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",2],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",2],[10,"from_u32","","Create an `IpAddr` instance from a 32-bits integer.",2],[10,"to_u32","","Convert an `IpAddr` instance to a 32-bits integer.",2],[4,"Output","",""],[10,"add","","",2],[4,"Output","",""],[10,"sub","","",2],[4,"Output","",""],[10,"bitxor","","",2],[4,"Output","",""],[10,"bitor","","",2],[4,"Output","",""],[10,"bitand","","",2],[4,"Output","",""],[10,"not","","",2],[10,"partial_cmp","","",2],[10,"cmp","","",2],[10,"from_std","","Create an `ipv4::IpAddr` instance from a Rust's standard library `IpAddr` instance.",2],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `ipv4::IpAddr` instance.",2],[10,"into_std","","Convert an `ipv4::IpAddr` instance into a Rust's standard library `IpAddr` instance.",2],[10,"fmt","","",2],[10,"from_str","","",2],[0,"ipv6","netaddr::addr","Provide operations over IPv6 addresses."],[1,"IpAddr","netaddr::addr::ipv6",""],[18,"MAX_PREFIXLEN","",""],[10,"decode","","",3],[10,"encode","","",3],[10,"hash","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"fmt","","",3],[10,"clone","","",3],[10,"version","","Get the corresponding IP address version.",3],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",3],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",3],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",3],[10,"from_u128","","Create an `IpAddr` instance from a 128-bits integer.",3],[10,"to_u128","","Convert an `IpAddr` instance to a 128-bits integer.",3],[10,"from_simd","","Create an `IpAddr` instance from a 128-bits SIMD integer.",3],[10,"to_simd","","Convert an `IpAddr` instance to a 128-bits SIMD integer.",3],[4,"Output","",""],[10,"add","","",3],[4,"Output","",""],[10,"sub","","",3],[4,"Output","",""],[10,"bitxor","","> Use SIMD to do operations on 128-bits integer.",3],[4,"Output","",""],[10,"bitor","","> Use SIMD to do operations on 128-bits integer.",3],[4,"Output","",""],[10,"bitand","","> Use SIMD to do operations on 128-bits integer.",3],[4,"Output","",""],[10,"not","","",3],[10,"partial_cmp","","",3],[10,"cmp","","",3],[10,"from_std","","Create an `ipv6::IpAddr` instance from a Rust's standard library `IpAddr` instance.",3],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `ipv6::IpAddr` instance.",3],[10,"into_std","","Convert an `ipv6::IpAddr` instance into a Rust's standard library `IpAddr` instance.",3],[10,"fmt","","",3],[10,"from_str","","",3],[10,"decode","netaddr::addr","",0],[10,"encode","","",0],[10,"hash","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"fmt","","",0],[10,"clone","","",0],[10,"decode","","",1],[10,"encode","","",1],[10,"hash","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"fmt","","",1],[10,"version","","Get the corresponding IP address version.",0],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",0],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",0],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",0],[4,"Output","",""],[10,"add","","",0],[4,"Output","",""],[10,"sub","","",0],[4,"Output","",""],[10,"bitxor","","",0],[4,"Output","",""],[10,"bitor","","",0],[4,"Output","",""],[10,"bitand","","",0],[4,"Output","",""],[10,"not","","",0],[10,"from_std","","Create an `IpAddr` instance from a Rust's standard library `IpAddr` instance.",0],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `IpAddr` instance.",0],[10,"into_std","","Convert an `IpAddr` instance into a Rust's standard library `IpAddr` instance.",0],[10,"fmt","","",0],[10,"from_str","","",0],[0,"net","netaddr","Provide operations over IP networks."],[1,"Hosts","netaddr::net",""],[2,"IpNetwork","","Describe an IP network."],[12,"Ipv4Network","","",4],[12,"Ipv6Network","","",4],[0,"ipv4","","Provide operations over IPv4 networks."],[1,"IpNetwork","netaddr::net::ipv4",""],[1,"Hosts","",""],[10,"decode","","",5],[10,"encode","","",5],[10,"hash","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"fmt","","",5],[10,"clone","","",5],[10,"version","","Get the corresponding IP address version.",5],[10,"address","","Get the network address for the network.",5],[10,"broadcast_address","","Get the broadcast address for the network.",5],[10,"prefix","","Get the length of the network prefix, in bits.",5],[10,"host_prefix","","Get the length of the host prefix, in bits.",5],[10,"num_addresses","","The total number of addresses in the network.",5],[10,"mask","","Get the mask of the network.",5],[10,"range","","Get the hosts range this network have.",5],[10,"contains","","`true` if this ip is contained in the network.",5],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",5],[10,"iter","","Iterate over all addresses of this network.",5],[10,"hosts_iter","","Iterate over all usable hosts of this network.",5],[10,"partial_cmp","","",5],[10,"cmp","","",5],[10,"fmt","","",5],[10,"clone","","",6],[4,"Item","",""],[10,"next","","",6],[10,"next_back","","",6],[0,"ipv6","netaddr::net","Provide operations over IPv6 networks."],[1,"IpNetwork","netaddr::net::ipv6",""],[1,"Hosts","",""],[10,"decode","","",7],[10,"encode","","",7],[10,"hash","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"fmt","","",7],[10,"clone","","",7],[10,"version","","Get the corresponding IP address version.",7],[10,"address","","Get the network address for the network.",7],[10,"broadcast_address","","Get the broadcast address for the network.",7],[10,"prefix","","Get the length of the network prefix, in bits.",7],[10,"host_prefix","","Get the length of the host prefix, in bits.",7],[10,"num_addresses","","The total number of addresses in the network.",7],[10,"mask","","Get the mask of the network.",7],[10,"range","","Get the hosts range this network have.",7],[10,"contains","","`true` if this ip is contained in the network.",7],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",7],[10,"iter","","Iterate over all addresses of this network.",7],[10,"hosts_iter","","Iterate over all usable hosts of this network.",7],[10,"partial_cmp","","",7],[10,"cmp","","",7],[10,"fmt","","",7],[10,"clone","","",8],[4,"Item","",""],[10,"next","","",8],[10,"next_back","","",8],[10,"decode","netaddr::net","",4],[10,"encode","","",4],[10,"hash","","",4],[10,"cmp","","",4],[10,"partial_cmp","","",4],[10,"lt","","",4],[10,"le","","",4],[10,"gt","","",4],[10,"ge","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"fmt","","",4],[10,"clone","","",4],[10,"version","","Get the corresponding IP address version.",4],[10,"address","","Get the network address for the network.",4],[10,"broadcast_address","","Get the broadcast address for the network.",4],[10,"prefix","","Get the length of the network prefix, in bits.",4],[10,"host_prefix","","Get the length of the host prefix, in bits.",4],[10,"num_addresses","","The total number of addresses in the network.",4],[10,"mask","","Get the mask of the network.",4],[10,"range","","Get the hosts range this network have.",4],[10,"contains","","`true` if this ip is contained in the network.",4],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",4],[10,"iter","","Iterate over all addresses of this network.",4],[10,"hosts_iter","","Iterate over all usable hosts of this network.",4],[10,"fmt","","",4],[10,"clone","","",9],[4,"Item","",""],[10,"next","","",9],[10,"next_back","","",9]],"paths":[[2,"IpAddr"],[2,"IpAddrVersion"],[1,"IpAddr"],[1,"IpAddr"],[2,"IpNetwork"],[1,"IpNetwork"],[1,"Hosts"],[1,"IpNetwork"],[1,"Hosts"],[1,"Hosts"]]};
searchIndex['rustc-serialize'] = {"items":[[0,"","rustc-serialize","Support code for encoding and decoding types."],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[10,"encode","collections::dlist","",10],[10,"decode","","",10],[10,"encode","collections::ring_buf","",11],[10,"decode","","",11],[10,"encode","collections::btree::map","",12],[10,"decode","","",12],[10,"encode","collections::btree::set","",13],[10,"decode","","",13],[10,"encode","std::collections::hash::map","",14],[10,"decode","","",14],[10,"encode","std::collections::hash::set","",15],[10,"decode","","",15],[10,"encode","collections::vec_map","",16],[10,"decode","","",16],[0,"base64","rustc-serialize","Base64 binary-to-text encoding"],[1,"Config","rustc-serialize::base64","Contains configuration parameters for `to_base64`."],[11,"char_set","","Character set to use",17],[11,"newline","","Newline to use",17],[11,"pad","","True to pad output with `=` characters",17],[11,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",17],[2,"CharacterSet","","Available encoding character sets"],[12,"Standard","","The standard character set (uses `+` and `/`)",18],[12,"UrlSafe","","The URL safe character set (uses `-` and `_`)",18],[2,"Newline","","Available newline types"],[12,"LF","","A linefeed (i.e. Unix-style newline)",19],[12,"CRLF","","A carriage return and a linefeed (i.e. Windows-style newline)",19],[2,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string"],[12,"InvalidBase64Byte","","The input contained a character not part of the base64 format",20],[12,"InvalidBase64Length","","The input had an invalid length",20],[5,"STANDARD","","Configuration for RFC 4648 standard base64 encoding"],[5,"URL_SAFE","","Configuration for RFC 4648 base64url encoding"],[5,"MIME","","Configuration for RFC 2045 MIME base64 encoding"],[6,"ToBase64","","A trait for converting a value to base64 encoding."],[9,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",21],[6,"FromBase64","","A trait for converting from base64 encoded values."],[9,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",22],[10,"fmt","","",20],[10,"description","","",20],[10,"detail","","",20],[0,"hex","rustc-serialize","Hex binary-to-text encoding"],[2,"FromHexError","rustc-serialize::hex","Errors that can occur when decoding a hex encoded string"],[12,"InvalidHexCharacter","","The input contained a character not part of the hex format",23],[12,"InvalidHexLength","","The input had an invalid length",23],[6,"ToHex","","A trait for converting a value to hexadecimal encoding"],[9,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",24],[6,"FromHex","","A trait for converting hexadecimal encoded values"],[9,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",25],[10,"fmt","","",23],[10,"description","","",23],[10,"detail","","",23],[0,"json","rustc-serialize","JSON parsing and serialization"],[1,"PrettyJson","rustc-serialize::json",""],[1,"AsJson","",""],[1,"AsPrettyJson","",""],[1,"Encoder","","A structure for implementing serialization to JSON."],[1,"PrettyEncoder","","Another encoder for JSON, but prints out human-readable JSON instead of\ncompact data"],[1,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x"],[1,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char."],[1,"Builder","","A Builder consumes a json::Parser to create a generic Json structure."],[1,"Decoder","","A structure to decode JSON to values in rust."],[2,"Json","","Represents a json value"],[12,"I64","","",26],[12,"U64","","",26],[12,"F64","","",26],[12,"String","","",26],[12,"Boolean","","",26],[12,"Array","","",26],[12,"Object","","",26],[12,"Null","","",26],[2,"ErrorCode","","The errors that can arise while parsing a JSON stream."],[12,"InvalidSyntax","","",27],[12,"InvalidNumber","","",27],[12,"EOFWhileParsingObject","","",27],[12,"EOFWhileParsingArray","","",27],[12,"EOFWhileParsingValue","","",27],[12,"EOFWhileParsingString","","",27],[12,"KeyMustBeAString","","",27],[12,"ExpectedColon","","",27],[12,"TrailingCharacters","","",27],[12,"TrailingComma","","",27],[12,"InvalidEscape","","",27],[12,"InvalidUnicodeCodePoint","","",27],[12,"LoneLeadingSurrogateInHexEscape","","",27],[12,"UnexpectedEndOfHexEscape","","",27],[12,"UnrecognizedHex","","",27],[12,"NotFourDigit","","",27],[12,"NotUtf8","","",27],[2,"ParserError","",""],[12,"SyntaxError","","msg, line, col",28],[12,"IoError","","",28],[2,"DecoderError","",""],[12,"ParseError","","",29],[12,"ExpectedError","","",29],[12,"MissingFieldError","","",29],[12,"UnknownVariantError","","",29],[12,"ApplicationError","","",29],[2,"JsonEvent","","The output of the streaming parser."],[12,"ObjectStart","","",30],[12,"ObjectEnd","","",30],[12,"ArrayStart","","",30],[12,"ArrayEnd","","",30],[12,"BooleanValue","","",30],[12,"I64Value","","",30],[12,"U64Value","","",30],[12,"F64Value","","",30],[12,"StringValue","","",30],[12,"NullValue","","",30],[12,"Error","","",30],[2,"StackElement","","StackElements compose a Stack.\nFor example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\nStackElements compositing the stack that represents foo.bar[3].x"],[12,"Index","","",31],[12,"Key","","",31],[3,"error_str","","Returns a readable error string for a given error code."],[3,"decode","","Shortcut function to decode a JSON `&str` into an object"],[3,"encode","","Shortcut function to encode a `T` into a JSON `String`"],[3,"as_json","","Create an `AsJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[3,"as_pretty_json","","Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[4,"Array","",""],[4,"Object","",""],[4,"BuilderError","",""],[4,"EncodeResult","",""],[4,"DecodeResult","",""],[6,"ToJson","","A trait for converting values to JSON"],[9,"to_json","","Converts the value of `self` to an instance of JSON",32],[10,"fmt","","",26],[10,"partial_cmp","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"fmt","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"fmt","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"fmt","","",27],[10,"description","","",29],[10,"detail","","",29],[10,"new","","Creates a new JSON encoder whose output will be written to the writer\nspecified.",33],[4,"Error","",""],[10,"emit_nil","","",33],[10,"emit_usize","","",33],[10,"emit_u64","","",33],[10,"emit_u32","","",33],[10,"emit_u16","","",33],[10,"emit_u8","","",33],[10,"emit_isize","","",33],[10,"emit_i64","","",33],[10,"emit_i32","","",33],[10,"emit_i16","","",33],[10,"emit_i8","","",33],[10,"emit_bool","","",33],[10,"emit_f64","","",33],[10,"emit_f32","","",33],[10,"emit_char","","",33],[10,"emit_str","","",33],[10,"emit_enum","","",33],[10,"emit_enum_variant","","",33],[10,"emit_enum_variant_arg","","",33],[10,"emit_enum_struct_variant","","",33],[10,"emit_enum_struct_variant_field","","",33],[10,"emit_struct","","",33],[10,"emit_struct_field","","",33],[10,"emit_tuple","","",33],[10,"emit_tuple_arg","","",33],[10,"emit_tuple_struct","","",33],[10,"emit_tuple_struct_arg","","",33],[10,"emit_option","","",33],[10,"emit_option_none","","",33],[10,"emit_option_some","","",33],[10,"emit_seq","","",33],[10,"emit_seq_elt","","",33],[10,"emit_map","","",33],[10,"emit_map_elt_key","","",33],[10,"emit_map_elt_val","","",33],[10,"new","","Creates a new encoder whose output will be written to the specified writer",34],[10,"set_indent","","Set the number of spaces to indent for each level.\nThis is safe to set during encoding.",34],[4,"Error","",""],[10,"emit_nil","","",34],[10,"emit_usize","","",34],[10,"emit_u64","","",34],[10,"emit_u32","","",34],[10,"emit_u16","","",34],[10,"emit_u8","","",34],[10,"emit_isize","","",34],[10,"emit_i64","","",34],[10,"emit_i32","","",34],[10,"emit_i16","","",34],[10,"emit_i8","","",34],[10,"emit_bool","","",34],[10,"emit_f64","","",34],[10,"emit_f32","","",34],[10,"emit_char","","",34],[10,"emit_str","","",34],[10,"emit_enum","","",34],[10,"emit_enum_variant","","",34],[10,"emit_enum_variant_arg","","",34],[10,"emit_enum_struct_variant","","",34],[10,"emit_enum_struct_variant_field","","",34],[10,"emit_struct","","",34],[10,"emit_struct_field","","",34],[10,"emit_tuple","","",34],[10,"emit_tuple_arg","","",34],[10,"emit_tuple_struct","","",34],[10,"emit_tuple_struct_arg","","",34],[10,"emit_option","","",34],[10,"emit_option_none","","",34],[10,"emit_option_some","","",34],[10,"emit_seq","","",34],[10,"emit_seq_elt","","",34],[10,"emit_map","","",34],[10,"emit_map_elt_key","","",34],[10,"emit_map_elt_val","","",34],[10,"encode","","",26],[10,"from_reader","","Decodes a json value from an `&mut io::Reader`",26],[10,"from_str","","Decodes a json value from a string",26],[10,"pretty","","Borrow this json object as a pretty object to generate a pretty\nrepresentation for it via `Show`.",26],[10,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",26],[10,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",26],[10,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",26],[10,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",26],[10,"as_object","","If the Json value is an Object, returns the associated BTreeMap.\nReturns None otherwise.",26],[10,"is_array","","Returns true if the Json value is an Array. Returns false otherwise.",26],[10,"as_array","","If the Json value is an Array, returns the associated vector.\nReturns None otherwise.",26],[10,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",26],[10,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",26],[10,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",26],[10,"is_i64","","Returns true if the Json value is a i64. Returns false otherwise.",26],[10,"is_u64","","Returns true if the Json value is a u64. Returns false otherwise.",26],[10,"is_f64","","Returns true if the Json value is a f64. Returns false otherwise.",26],[10,"as_i64","","If the Json value is a number, return or cast it to a i64.\nReturns None otherwise.",26],[10,"as_u64","","If the Json value is a number, return or cast it to a u64.\nReturns None otherwise.",26],[10,"as_f64","","If the Json value is a number, return or cast it to a f64.\nReturns None otherwise.",26],[10,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",26],[10,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",26],[10,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",26],[10,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",26],[4,"Output","",""],[10,"index","","",26],[4,"Output","",""],[10,"index","","",26],[10,"fmt","","",30],[10,"clone","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"fmt","","",31],[10,"clone","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"new","","",35],[10,"len","","Returns The number of elements in the Stack.",35],[10,"is_empty","","Returns true if the stack is empty.",35],[10,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",35],[10,"is_equal_to","","Compares this stack with an array of StackElements.",35],[10,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"top","","Returns the top-most element (if any).",35],[4,"Item","",""],[10,"next","","",36],[10,"new","","Creates the JSON parser.",36],[10,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",36],[10,"new","","Create a JSON Builder.",37],[10,"build","","",37],[10,"new","","Creates a new decoder instance for decoding the specified JSON value.",38],[4,"Error","",""],[10,"read_nil","","",38],[10,"read_usize","","",38],[10,"read_u8","","",38],[10,"read_u16","","",38],[10,"read_u32","","",38],[10,"read_u64","","",38],[10,"read_isize","","",38],[10,"read_i8","","",38],[10,"read_i16","","",38],[10,"read_i32","","",38],[10,"read_i64","","",38],[10,"read_f32","","",38],[10,"read_f64","","",38],[10,"read_bool","","",38],[10,"read_char","","",38],[10,"read_str","","",38],[10,"read_enum","","",38],[10,"read_enum_variant","","",38],[10,"read_enum_variant_arg","","",38],[10,"read_enum_struct_variant","","",38],[10,"read_enum_struct_variant_field","","",38],[10,"read_struct","","",38],[10,"read_struct_field","","",38],[10,"read_tuple","","",38],[10,"read_tuple_arg","","",38],[10,"read_tuple_struct","","",38],[10,"read_tuple_struct_arg","","",38],[10,"read_option","","",38],[10,"read_seq","","",38],[10,"read_seq_elt","","",38],[10,"read_map","","",38],[10,"read_map_elt_key","","",38],[10,"read_map_elt_val","","",38],[10,"error","","",38],[10,"to_json","","",26],[10,"to_json","collections::string","",0],[10,"to_json","collections::vec","",3],[10,"to_json","collections::btree::map","",12],[10,"to_json","std::collections::hash::map","",14],[10,"to_json","core::option","",4],[10,"fmt","rustc-serialize::json","Encodes a json value into a string",26],[10,"fmt","","Encodes a json value into a string",39],[10,"fmt","","Encodes a json value into a string",40],[10,"indent","","Set the indentation level for the emitted JSON",41],[10,"fmt","","Encodes a json value into a string",41],[10,"from_str","","",26],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[6,"Decoder","rustc-serialize",""],[17,"Error","rustc-serialize::Decoder",""],[9,"read_nil","rustc-serialize","",42],[9,"read_usize","","",42],[9,"read_u64","","",42],[9,"read_u32","","",42],[9,"read_u16","","",42],[9,"read_u8","","",42],[9,"read_isize","","",42],[9,"read_i64","","",42],[9,"read_i32","","",42],[9,"read_i16","","",42],[9,"read_i8","","",42],[9,"read_bool","","",42],[9,"read_f64","","",42],[9,"read_f32","","",42],[9,"read_char","","",42],[9,"read_str","","",42],[9,"read_enum","","",42],[9,"read_enum_variant","","",42],[9,"read_enum_variant_arg","","",42],[9,"read_enum_struct_variant","","",42],[9,"read_enum_struct_variant_field","","",42],[9,"read_struct","","",42],[9,"read_struct_field","","",42],[9,"read_tuple","","",42],[9,"read_tuple_arg","","",42],[9,"read_tuple_struct","","",42],[9,"read_tuple_struct_arg","","",42],[9,"read_option","","",42],[9,"read_seq","","",42],[9,"read_seq_elt","","",42],[9,"read_map","","",42],[9,"read_map_elt_key","","",42],[9,"read_map_elt_val","","",42],[9,"error","","",42],[6,"Encoder","",""],[17,"Error","rustc-serialize::Encoder",""],[9,"emit_nil","rustc-serialize","",43],[9,"emit_usize","","",43],[9,"emit_u64","","",43],[9,"emit_u32","","",43],[9,"emit_u16","","",43],[9,"emit_u8","","",43],[9,"emit_isize","","",43],[9,"emit_i64","","",43],[9,"emit_i32","","",43],[9,"emit_i16","","",43],[9,"emit_i8","","",43],[9,"emit_bool","","",43],[9,"emit_f64","","",43],[9,"emit_f32","","",43],[9,"emit_char","","",43],[9,"emit_str","","",43],[9,"emit_enum","","",43],[9,"emit_enum_variant","","",43],[9,"emit_enum_variant_arg","","",43],[9,"emit_enum_struct_variant","","",43],[9,"emit_enum_struct_variant_field","","",43],[9,"emit_struct","","",43],[9,"emit_struct_field","","",43],[9,"emit_tuple","","",43],[9,"emit_tuple_arg","","",43],[9,"emit_tuple_struct","","",43],[9,"emit_tuple_struct_arg","","",43],[9,"emit_option","","",43],[9,"emit_option_none","","",43],[9,"emit_option_some","","",43],[9,"emit_seq","","",43],[9,"emit_seq_elt","","",43],[9,"emit_map","","",43],[9,"emit_map_elt_key","","",43],[9,"emit_map_elt_val","","",43],[6,"Decodable","",""],[9,"decode","","",44],[6,"Encodable","",""],[9,"encode","","",45],[6,"DecoderHelpers","",""],[9,"read_to_vec","","",46],[6,"EncoderHelpers","",""],[9,"emit_from_vec","","",47]],"paths":[[1,"String"],[1,"Box"],[1,"Rc"],[1,"Vec"],[2,"Option"],[1,"Path"],[1,"Path"],[1,"Cell"],[1,"RefCell"],[1,"Arc"],[1,"DList"],[1,"RingBuf"],[1,"BTreeMap"],[1,"BTreeSet"],[1,"HashMap"],[1,"HashSet"],[1,"VecMap"],[1,"Config"],[2,"CharacterSet"],[2,"Newline"],[2,"FromBase64Error"],[6,"ToBase64"],[6,"FromBase64"],[2,"FromHexError"],[6,"ToHex"],[6,"FromHex"],[2,"Json"],[2,"ErrorCode"],[2,"ParserError"],[2,"DecoderError"],[2,"JsonEvent"],[2,"StackElement"],[6,"ToJson"],[1,"Encoder"],[1,"PrettyEncoder"],[1,"Stack"],[1,"Parser"],[1,"Builder"],[1,"Decoder"],[1,"PrettyJson"],[1,"AsJson"],[1,"AsPrettyJson"],[6,"Decoder"],[6,"Encoder"],[6,"Decodable"],[6,"Encodable"],[6,"DecoderHelpers"],[6,"EncoderHelpers"]]};

searchIndex['log'] = {"items":[[0,"","log","Utilities for program-wide and customizable logging"],[1,"LogLevel","","Wraps the log level with fmt implementations."],[1,"LogRecord","","A LogRecord is created by the logging macros, and passed as the only\nargument to Loggers."],[11,"module_path","","The module path of where the LogRecord originated.",0],[11,"level","","The LogLevel of this record.",0],[11,"args","","The arguments from the log line.",0],[11,"file","","The file of where the LogRecord originated.",0],[11,"line","","The line number of where the LogRecord originated.",0],[3,"set_logger","","Replaces the task-local logger with the specified logger, returning the old\nlogger."],[0,"macros","","Logging macros"],[18,"MAX_LOG_LEVEL","","Maximum logging level of a module that can be specified. Common logging\nlevels are found in the DEBUG/INFO/WARN/ERROR constants."],[18,"DEBUG","","Debug log level"],[18,"INFO","","Info log level"],[18,"WARN","","Warn log level"],[18,"ERROR","","Error log level"],[6,"Logger","","A trait used to represent an interface to a task-local logger. Each task\ncan have its own custom logger which can respond to logging messages\nhowever it likes."],[9,"log","","Logs a single message described by the `record`.",1],[10,"fmt","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"fmt","","",2],[10,"fmt","","",0],[15,"log!","","The standard logging macro"],[15,"error!","","A convenience macro for logging at the error log level."],[15,"warn!","","A convenience macro for logging at the warning log level."],[15,"info!","","A convenience macro for logging at the info log level."],[15,"debug!","","A convenience macro for logging at the debug log level. This macro can also\nbe omitted at compile time by passing `--cfg ndebug` to the compiler. If\nthis option is not passed, then debug statements will be compiled."],[15,"log_enabled!","","A macro to test whether a log level is enabled for the current module."]],"paths":[[1,"LogRecord"],[6,"Logger"],[1,"LogLevel"]]};

searchIndex['regex'] = {"items":[[0,"","regex","This crate provides a native implementation of regular expressions that is\nheavily based on RE2 both in syntax and in implementation. Notably,\nbackreferences and arbitrary lookahead/lookbehind assertions are not\nprovided. In return, regular expression searching provided by this package\nhas excellent worst case performance. The specific syntax supported is\ndocumented further down."],[1,"Error","","Error corresponds to something that can go wrong while parsing\na regular expression."],[11,"pos","","The *approximate* character index of where the error occurred.",0],[11,"msg","","A message describing the error.",0],[1,"Captures","","Captures represents a group of captured strings for a single match."],[1,"SubCaptures","","An iterator over capture groups for a particular match of a regular\nexpression."],[1,"SubCapturesPos","","An iterator over capture group positions for a particular match of a\nregular expression."],[1,"FindCaptures","","An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression."],[1,"FindMatches","","An iterator over all non-overlapping matches for a particular string."],[1,"NoExpand","","NoExpand indicates literal string replacement."],[1,"RegexSplits","","Yields all substrings delimited by a regular expression match."],[1,"RegexSplitsN","","Yields at most `N` substrings delimited by a regular expression match."],[2,"Regex","","A compiled regular expression"],[3,"quote","","Escapes all regular expression meta characters in `text`."],[3,"is_match","","Tests if the given regular expression matches somewhere in the text given."],[10,"fmt","","",0],[10,"fmt","","",0],[10,"clone","","",1],[10,"fmt","","Shows the original regular expression.",1],[10,"fmt","","Shows the original regular expression.",1],[10,"new","","Compiles a dynamic regular expression. Once compiled, it can be\nused repeatedly to search, split or replace text in a string.",1],[10,"is_match","","Returns true if and only if the regex matches the string given.",1],[10,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",1],[10,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",1],[10,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",1],[10,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter` (except it\nyields information about submatches).",1],[10,"split","","Returns an iterator of substrings of `text` delimited by a match\nof the regular expression.\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.",1],[10,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.)\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.\nThe remainder of the string that is not split will be the last element\nin the iterator.",1],[10,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches'\n`Captures` and returns the replaced string.",1],[10,"replace_all","","Replaces all non-overlapping matches in `text` with the\nreplacement provided. This is the same as calling `replacen` with\n`limit` set to `0`.",1],[10,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",1],[10,"as_str","","Returns the original string of this regex.",1],[10,"reg_replace","","",2],[10,"next","","",3],[10,"next","","",4],[10,"pos","","Returns the start and end positions of the Nth capture group.\nReturns `None` if `i` is not a valid capture group or if the capture\ngroup did not match anything.\nThe positions returned are *always* byte indices with respect to the\noriginal string matched.",5],[10,"at","","Returns the matched string for the capture group `i`.  If `i` isn't\na valid capture group or didn't match anything, then `None` is\nreturned.",5],[10,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn't a valid capture group or didn't match anything, then\n`None` is returned.",5],[10,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",5],[10,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",5],[10,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",5],[10,"len","","Returns the number of captured groups.",5],[10,"is_empty","","Returns if there are no captured groups.",5],[10,"next","","",6],[10,"next","","",7],[10,"next","","",8],[10,"next","","",9],[6,"Replacer","","Replacer describes types that can be used to replace matches in a string."],[9,"reg_replace","","Returns a possibly owned string that is used to replace the match\ncorresponding to the `caps` capture group.",10]],"paths":[[1,"Error"],[2,"Regex"],[1,"NoExpand"],[1,"RegexSplits"],[1,"RegexSplitsN"],[1,"Captures"],[1,"SubCaptures"],[1,"SubCapturesPos"],[1,"FindCaptures"],[1,"FindMatches"],[6,"Replacer"]]};

initSearch(searchIndex);
