var searchIndex = {};
searchIndex['netaddr'] = {"items":[[0,"","netaddr",""],[0,"addr","","Provide operations over IP addresses."],[2,"IpAddr","netaddr::addr","Describe an IP address"],[12,"Ipv4Addr","","",0],[12,"Ipv6Addr","","",0],[2,"IpAddrVersion","","Describe the version of an IP address."],[12,"Ipv4","","",1],[12,"Ipv6","","",1],[0,"ipv4","","Provide operations over IPv4 addresses."],[1,"IpAddr","netaddr::addr::ipv4",""],[18,"MAX_PREFIXLEN","",""],[10,"decode","","",2],[10,"encode","","",2],[10,"hash","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"version","","Get the corresponding IP address version.",2],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",2],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",2],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",2],[10,"from_u32","","Create an `IpAddr` instance from a 32-bits integer.",2],[10,"to_u32","","Convert an `IpAddr` instance to a 32-bits integer.",2],[10,"add","","",2],[10,"sub","","",2],[10,"bitxor","","",2],[10,"bitor","","",2],[10,"bitand","","",2],[10,"not","","",2],[10,"partial_cmp","","",2],[10,"cmp","","",2],[10,"from_std","","Create an `ipv4::IpAddr` instance from a Rust's standard library `IpAddr` instance.",2],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `ipv4::IpAddr` instance.",2],[10,"into_std","","Convert an `ipv4::IpAddr` instance into a Rust's standard library `IpAddr` instance.",2],[10,"fmt","","",2],[10,"from_str","","",2],[0,"ipv6","netaddr::addr","Provide operations over IPv6 addresses."],[1,"IpAddr","netaddr::addr::ipv6",""],[18,"MAX_PREFIXLEN","",""],[10,"decode","","",3],[10,"encode","","",3],[10,"hash","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"version","","Get the corresponding IP address version.",3],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",3],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",3],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",3],[10,"from_u128","","Create an `IpAddr` instance from a 128-bits integer.",3],[10,"to_u128","","Convert an `IpAddr` instance to a 128-bits integer.",3],[10,"from_simd","","Create an `IpAddr` instance from a 128-bits SIMD integer.",3],[10,"to_simd","","Convert an `IpAddr` instance to a 128-bits SIMD integer.",3],[10,"add","","",3],[10,"sub","","",3],[10,"bitxor","","> Use SIMD to do operations on 128-bits integer.",3],[10,"bitor","","> Use SIMD to do operations on 128-bits integer.",3],[10,"bitand","","> Use SIMD to do operations on 128-bits integer.",3],[10,"not","","",3],[10,"partial_cmp","","",3],[10,"cmp","","",3],[10,"from_std","","Create an `ipv6::IpAddr` instance from a Rust's standard library `IpAddr` instance.",3],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `ipv6::IpAddr` instance.",3],[10,"into_std","","Convert an `ipv6::IpAddr` instance into a Rust's standard library `IpAddr` instance.",3],[10,"fmt","","",3],[10,"from_str","","",3],[10,"decode","netaddr::addr","",0],[10,"encode","","",0],[10,"hash","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"decode","","",1],[10,"encode","","",1],[10,"hash","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"fmt","","",1],[10,"version","","Get the corresponding IP address version.",0],[10,"max_prefixlen","","The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.",0],[10,"with_prefixlen","","Create an IP mask with the specified prefixlen.",0],[10,"packed","","The binary representation of this address - a bytes vector of the appropriate length (most significant octet first).\nThis is 4 bytes for IPv4 and 16 bytes for IPv6.",0],[10,"add","","",0],[10,"sub","","",0],[10,"bitxor","","",0],[10,"bitor","","",0],[10,"bitand","","",0],[10,"not","","",0],[10,"from_std","","Create an `IpAddr` instance from a Rust's standard library `IpAddr` instance.",0],[10,"to_std","","Create a Rust's standard library `IpAddr` instance from an `IpAddr` instance.",0],[10,"into_std","","Convert an `IpAddr` instance into a Rust's standard library `IpAddr` instance.",0],[10,"fmt","","",0],[10,"from_str","","",0],[0,"net","netaddr","Provide operations over IP networks."],[1,"Hosts","netaddr::net",""],[2,"IpNetwork","","Describe an IP network."],[12,"Ipv4Network","","",4],[12,"Ipv6Network","","",4],[0,"ipv4","","Provide operations over IPv4 networks."],[1,"IpNetwork","netaddr::net::ipv4",""],[1,"Hosts","",""],[10,"decode","","",5],[10,"encode","","",5],[10,"hash","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"version","","Get the corresponding IP address version.",5],[10,"address","","Get the network address for the network.",5],[10,"broadcast_address","","Get the broadcast address for the network.",5],[10,"prefix","","Get the length of the network prefix, in bits.",5],[10,"host_prefix","","Get the length of the host prefix, in bits.",5],[10,"num_addresses","","The total number of addresses in the network.",5],[10,"mask","","Get the mask of the network.",5],[10,"range","","Get the hosts range this network have.",5],[10,"contains","","`true` if this ip is contained in the network.",5],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",5],[10,"iter","","Iterate over all addresses of this network.",5],[10,"hosts_iter","","Iterate over all usable hosts of this network.",5],[10,"partial_cmp","","",5],[10,"cmp","","",5],[10,"fmt","","",5],[10,"clone","","",6],[10,"next","","",6],[10,"next_back","","",6],[0,"ipv6","netaddr::net","Provide operations over IPv6 networks."],[1,"IpNetwork","netaddr::net::ipv6",""],[1,"Hosts","",""],[10,"decode","","",7],[10,"encode","","",7],[10,"hash","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"clone","","",7],[10,"version","","Get the corresponding IP address version.",7],[10,"address","","Get the network address for the network.",7],[10,"broadcast_address","","Get the broadcast address for the network.",7],[10,"prefix","","Get the length of the network prefix, in bits.",7],[10,"host_prefix","","Get the length of the host prefix, in bits.",7],[10,"num_addresses","","The total number of addresses in the network.",7],[10,"mask","","Get the mask of the network.",7],[10,"range","","Get the hosts range this network have.",7],[10,"contains","","`true` if this ip is contained in the network.",7],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",7],[10,"iter","","Iterate over all addresses of this network.",7],[10,"hosts_iter","","Iterate over all usable hosts of this network.",7],[10,"partial_cmp","","",7],[10,"cmp","","",7],[10,"fmt","","",7],[10,"clone","","",8],[10,"next","","",8],[10,"next_back","","",8],[10,"decode","netaddr::net","",4],[10,"encode","","",4],[10,"hash","","",4],[10,"cmp","","",4],[10,"partial_cmp","","",4],[10,"lt","","",4],[10,"le","","",4],[10,"gt","","",4],[10,"ge","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"clone","","",4],[10,"version","","Get the corresponding IP address version.",4],[10,"address","","Get the network address for the network.",4],[10,"broadcast_address","","Get the broadcast address for the network.",4],[10,"prefix","","Get the length of the network prefix, in bits.",4],[10,"host_prefix","","Get the length of the host prefix, in bits.",4],[10,"num_addresses","","The total number of addresses in the network.",4],[10,"mask","","Get the mask of the network.",4],[10,"range","","Get the hosts range this network have.",4],[10,"contains","","`true` if this ip is contained in the network.",4],[10,"overlaps","","`true` if this network is partly or wholly contained in other or other is wholly contained in this network.",4],[10,"iter","","Iterate over all addresses of this network.",4],[10,"hosts_iter","","Iterate over all usable hosts of this network.",4],[10,"fmt","","",4],[10,"clone","","",9],[10,"next","","",9],[10,"next_back","","",9]],"paths":[[2,"IpAddr"],[2,"IpAddrVersion"],[1,"IpAddr"],[1,"IpAddr"],[2,"IpNetwork"],[1,"IpNetwork"],[1,"Hosts"],[1,"IpNetwork"],[1,"Hosts"],[1,"Hosts"]]};
searchIndex['rustc-serialize'] = {"items":[[0,"","rustc-serialize","Support code for encoding and decoding types."],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[10,"encode","collections::dlist","",10],[10,"decode","","",10],[10,"encode","collections::ring_buf","",11],[10,"decode","","",11],[10,"encode","collections::btree::map","",12],[10,"decode","","",12],[10,"encode","collections::btree::set","",13],[10,"decode","","",13],[10,"encode","collections::enum_set","",14],[10,"decode","","",14],[10,"encode","std::collections::hash::map","",15],[10,"decode","","",15],[10,"encode","std::collections::hash::set","",16],[10,"decode","","",16],[10,"encode","collections::vec_map","",17],[10,"decode","","",17],[0,"base64","rustc-serialize","Base64 binary-to-text encoding"],[1,"Config","rustc-serialize::base64","Contains configuration parameters for `to_base64`."],[11,"char_set","","Character set to use",18],[11,"newline","","Newline to use",18],[11,"pad","","True to pad output with `=` characters",18],[11,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",18],[2,"CharacterSet","","Available encoding character sets"],[12,"Standard","","The standard character set (uses `+` and `/`)",19],[12,"UrlSafe","","The URL safe character set (uses `-` and `_`)",19],[2,"Newline","","Available newline types"],[12,"LF","","A linefeed (i.e. Unix-style newline)",20],[12,"CRLF","","A carriage return and a linefeed (i.e. Windows-style newline)",20],[2,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string"],[12,"InvalidBase64Byte","","The input contained a character not part of the base64 format",21],[12,"InvalidBase64Length","","The input had an invalid length",21],[5,"STANDARD","","Configuration for RFC 4648 standard base64 encoding"],[5,"URL_SAFE","","Configuration for RFC 4648 base64url encoding"],[5,"MIME","","Configuration for RFC 2045 MIME base64 encoding"],[6,"ToBase64","","A trait for converting a value to base64 encoding."],[9,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",22],[6,"FromBase64","","A trait for converting from base64 encoded values."],[9,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",23],[10,"fmt","","",21],[10,"description","","",21],[10,"detail","","",21],[0,"hex","rustc-serialize","Hex binary-to-text encoding"],[2,"FromHexError","rustc-serialize::hex","Errors that can occur when decoding a hex encoded string"],[12,"InvalidHexCharacter","","The input contained a character not part of the hex format",24],[12,"InvalidHexLength","","The input had an invalid length",24],[6,"ToHex","","A trait for converting a value to hexadecimal encoding"],[9,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",25],[6,"FromHex","","A trait for converting hexadecimal encoded values"],[9,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",26],[10,"fmt","","",24],[10,"description","","",24],[10,"detail","","",24],[0,"json","rustc-serialize","JSON parsing and serialization"],[1,"Encoder","rustc-serialize::json","A structure for implementing serialization to JSON."],[1,"PrettyEncoder","","Another encoder for JSON, but prints out human-readable JSON instead of\ncompact data"],[1,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x"],[1,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char."],[1,"Builder","","A Builder consumes a json::Parser to create a generic Json structure."],[1,"Decoder","","A structure to decode JSON to values in rust."],[2,"Json","","Represents a json value"],[12,"I64","","",27],[12,"U64","","",27],[12,"F64","","",27],[12,"String","","",27],[12,"Boolean","","",27],[12,"Array","","",27],[12,"Object","","",27],[12,"Null","","",27],[2,"ErrorCode","","The errors that can arise while parsing a JSON stream."],[12,"InvalidSyntax","","",28],[12,"InvalidNumber","","",28],[12,"EOFWhileParsingObject","","",28],[12,"EOFWhileParsingArray","","",28],[12,"EOFWhileParsingValue","","",28],[12,"EOFWhileParsingString","","",28],[12,"KeyMustBeAString","","",28],[12,"ExpectedColon","","",28],[12,"TrailingCharacters","","",28],[12,"TrailingComma","","",28],[12,"InvalidEscape","","",28],[12,"InvalidUnicodeCodePoint","","",28],[12,"LoneLeadingSurrogateInHexEscape","","",28],[12,"UnexpectedEndOfHexEscape","","",28],[12,"UnrecognizedHex","","",28],[12,"NotFourDigit","","",28],[12,"NotUtf8","","",28],[2,"ParserError","",""],[12,"SyntaxError","","msg, line, col",29],[12,"IoError","","",29],[2,"DecoderError","",""],[12,"ParseError","","",30],[12,"ExpectedError","","",30],[12,"MissingFieldError","","",30],[12,"UnknownVariantError","","",30],[12,"ApplicationError","","",30],[2,"JsonEvent","","The output of the streaming parser."],[12,"ObjectStart","","",31],[12,"ObjectEnd","","",31],[12,"ArrayStart","","",31],[12,"ArrayEnd","","",31],[12,"BooleanValue","","",31],[12,"I64Value","","",31],[12,"U64Value","","",31],[12,"F64Value","","",31],[12,"StringValue","","",31],[12,"NullValue","","",31],[12,"Error","","",31],[2,"StackElement","","StackElements compose a Stack.\nFor example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\nStackElements compositing the stack that represents foo.bar[3].x"],[12,"Index","","",32],[12,"Key","","",32],[3,"error_str","","Returns a readable error string for a given error code."],[3,"decode","","Shortcut function to decode a JSON `&str` into an object"],[3,"encode","","Shortcut function to encode a `T` into a JSON `String`"],[3,"escape_bytes","",""],[3,"from_reader","","Decodes a json value from an `&mut io::Reader`"],[3,"from_str","","Decodes a json value from a string"],[4,"Array","",""],[4,"Object","",""],[4,"BuilderError","",""],[4,"EncodeResult","",""],[4,"DecodeResult","",""],[6,"ToJson","","A trait for converting values to JSON"],[9,"to_json","","Converts the value of `self` to an instance of JSON",33],[10,"partial_cmp","","",27],[10,"lt","","",27],[10,"le","","",27],[10,"gt","","",27],[10,"ge","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"eq","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"fmt","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"fmt","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"clone","","",30],[10,"fmt","","",28],[10,"description","","",30],[10,"detail","","",30],[10,"new","","Creates a new JSON encoder whose output will be written to the writer\nspecified.",34],[10,"buffer_encode","","Encode the specified struct into a json [u8]",34],[10,"emit_nil","","",34],[10,"emit_uint","","",34],[10,"emit_u64","","",34],[10,"emit_u32","","",34],[10,"emit_u16","","",34],[10,"emit_u8","","",34],[10,"emit_int","","",34],[10,"emit_i64","","",34],[10,"emit_i32","","",34],[10,"emit_i16","","",34],[10,"emit_i8","","",34],[10,"emit_bool","","",34],[10,"emit_f64","","",34],[10,"emit_f32","","",34],[10,"emit_char","","",34],[10,"emit_str","","",34],[10,"emit_enum","","",34],[10,"emit_enum_variant","","",34],[10,"emit_enum_variant_arg","","",34],[10,"emit_enum_struct_variant","","",34],[10,"emit_enum_struct_variant_field","","",34],[10,"emit_struct","","",34],[10,"emit_struct_field","","",34],[10,"emit_tuple","","",34],[10,"emit_tuple_arg","","",34],[10,"emit_tuple_struct","","",34],[10,"emit_tuple_struct_arg","","",34],[10,"emit_option","","",34],[10,"emit_option_none","","",34],[10,"emit_option_some","","",34],[10,"emit_seq","","",34],[10,"emit_seq_elt","","",34],[10,"emit_map","","",34],[10,"emit_map_elt_key","","",34],[10,"emit_map_elt_val","","",34],[10,"new","","Creates a new encoder whose output will be written to the specified writer",35],[10,"set_indent","","Set the number of spaces to indent for each level.\nThis is safe to set during encoding.",35],[10,"emit_nil","","",35],[10,"emit_uint","","",35],[10,"emit_u64","","",35],[10,"emit_u32","","",35],[10,"emit_u16","","",35],[10,"emit_u8","","",35],[10,"emit_int","","",35],[10,"emit_i64","","",35],[10,"emit_i32","","",35],[10,"emit_i16","","",35],[10,"emit_i8","","",35],[10,"emit_bool","","",35],[10,"emit_f64","","",35],[10,"emit_f32","","",35],[10,"emit_char","","",35],[10,"emit_str","","",35],[10,"emit_enum","","",35],[10,"emit_enum_variant","","",35],[10,"emit_enum_variant_arg","","",35],[10,"emit_enum_struct_variant","","",35],[10,"emit_enum_struct_variant_field","","",35],[10,"emit_struct","","",35],[10,"emit_struct_field","","",35],[10,"emit_tuple","","",35],[10,"emit_tuple_arg","","",35],[10,"emit_tuple_struct","","",35],[10,"emit_tuple_struct_arg","","",35],[10,"emit_option","","",35],[10,"emit_option_none","","",35],[10,"emit_option_some","","",35],[10,"emit_seq","","",35],[10,"emit_seq_elt","","",35],[10,"emit_map","","",35],[10,"emit_map_elt_key","","",35],[10,"emit_map_elt_val","","",35],[10,"encode","","",27],[10,"to_writer","","Encodes a json value into an io::writer. Uses a single line.",27],[10,"to_pretty_writer","","Encodes a json value into an io::writer.\nPretty-prints in a more readable format.",27],[10,"to_pretty_str","","Encodes a json value into a string",27],[10,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",27],[10,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",27],[10,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",27],[10,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",27],[10,"as_object","","If the Json value is an Object, returns the associated BTreeMap.\nReturns None otherwise.",27],[10,"is_array","","Returns true if the Json value is an Array. Returns false otherwise.",27],[10,"as_array","","If the Json value is an Array, returns the associated vector.\nReturns None otherwise.",27],[10,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",27],[10,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",27],[10,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",27],[10,"is_i64","","Returns true if the Json value is a i64. Returns false otherwise.",27],[10,"is_u64","","Returns true if the Json value is a u64. Returns false otherwise.",27],[10,"is_f64","","Returns true if the Json value is a f64. Returns false otherwise.",27],[10,"as_i64","","If the Json value is a number, return or cast it to a i64.\nReturns None otherwise.",27],[10,"as_u64","","If the Json value is a number, return or cast it to a u64.\nReturns None otherwise.",27],[10,"as_f64","","If the Json value is a number, return or cast it to a f64.\nReturns None otherwise.",27],[10,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",27],[10,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",27],[10,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",27],[10,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",27],[10,"index","","",27],[10,"index","","",27],[10,"fmt","","",31],[10,"clone","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"fmt","","",32],[10,"clone","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"new","","",36],[10,"len","","Returns The number of elements in the Stack.",36],[10,"is_empty","","Returns true if the stack is empty.",36],[10,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",36],[10,"is_equal_to","","Compares this stack with an array of StackElements.",36],[10,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",36],[10,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",36],[10,"top","","Returns the top-most element (if any).",36],[10,"next","","",37],[10,"new","","Creates the JSON parser.",37],[10,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",37],[10,"new","","Create a JSON Builder.",38],[10,"build","","",38],[10,"new","","Creates a new decoder instance for decoding the specified JSON value.",39],[10,"read_nil","","",39],[10,"read_uint","","",39],[10,"read_u8","","",39],[10,"read_u16","","",39],[10,"read_u32","","",39],[10,"read_u64","","",39],[10,"read_int","","",39],[10,"read_i8","","",39],[10,"read_i16","","",39],[10,"read_i32","","",39],[10,"read_i64","","",39],[10,"read_f32","","",39],[10,"read_f64","","",39],[10,"read_bool","","",39],[10,"read_char","","",39],[10,"read_str","","",39],[10,"read_enum","","",39],[10,"read_enum_variant","","",39],[10,"read_enum_variant_arg","","",39],[10,"read_enum_struct_variant","","",39],[10,"read_enum_struct_variant_field","","",39],[10,"read_struct","","",39],[10,"read_struct_field","","",39],[10,"read_tuple","","",39],[10,"read_tuple_arg","","",39],[10,"read_tuple_struct","","",39],[10,"read_tuple_struct_arg","","",39],[10,"read_option","","",39],[10,"read_seq","","",39],[10,"read_seq_elt","","",39],[10,"read_map","","",39],[10,"read_map_elt_key","","",39],[10,"read_map_elt_val","","",39],[10,"error","","",39],[10,"to_json","","",27],[10,"to_json","collections::string","",0],[10,"to_json","collections::vec","",3],[10,"to_json","collections::btree::map","",12],[10,"to_json","std::collections::hash::map","",15],[10,"to_json","core::option","",4],[10,"fmt","rustc-serialize::json","Encodes a json value into a string",27],[10,"from_str","","",27],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[6,"Decoder","rustc-serialize",""],[9,"read_nil","","",40],[9,"read_uint","","",40],[9,"read_u64","","",40],[9,"read_u32","","",40],[9,"read_u16","","",40],[9,"read_u8","","",40],[9,"read_int","","",40],[9,"read_i64","","",40],[9,"read_i32","","",40],[9,"read_i16","","",40],[9,"read_i8","","",40],[9,"read_bool","","",40],[9,"read_f64","","",40],[9,"read_f32","","",40],[9,"read_char","","",40],[9,"read_str","","",40],[9,"read_enum","","",40],[9,"read_enum_variant","","",40],[9,"read_enum_variant_arg","","",40],[9,"read_enum_struct_variant","","",40],[9,"read_enum_struct_variant_field","","",40],[9,"read_struct","","",40],[9,"read_struct_field","","",40],[9,"read_tuple","","",40],[9,"read_tuple_arg","","",40],[9,"read_tuple_struct","","",40],[9,"read_tuple_struct_arg","","",40],[9,"read_option","","",40],[9,"read_seq","","",40],[9,"read_seq_elt","","",40],[9,"read_map","","",40],[9,"read_map_elt_key","","",40],[9,"read_map_elt_val","","",40],[9,"error","","",40],[6,"Encoder","",""],[9,"emit_nil","","",41],[9,"emit_uint","","",41],[9,"emit_u64","","",41],[9,"emit_u32","","",41],[9,"emit_u16","","",41],[9,"emit_u8","","",41],[9,"emit_int","","",41],[9,"emit_i64","","",41],[9,"emit_i32","","",41],[9,"emit_i16","","",41],[9,"emit_i8","","",41],[9,"emit_bool","","",41],[9,"emit_f64","","",41],[9,"emit_f32","","",41],[9,"emit_char","","",41],[9,"emit_str","","",41],[9,"emit_enum","","",41],[9,"emit_enum_variant","","",41],[9,"emit_enum_variant_arg","","",41],[9,"emit_enum_struct_variant","","",41],[9,"emit_enum_struct_variant_field","","",41],[9,"emit_struct","","",41],[9,"emit_struct_field","","",41],[9,"emit_tuple","","",41],[9,"emit_tuple_arg","","",41],[9,"emit_tuple_struct","","",41],[9,"emit_tuple_struct_arg","","",41],[9,"emit_option","","",41],[9,"emit_option_none","","",41],[9,"emit_option_some","","",41],[9,"emit_seq","","",41],[9,"emit_seq_elt","","",41],[9,"emit_map","","",41],[9,"emit_map_elt_key","","",41],[9,"emit_map_elt_val","","",41],[6,"Decodable","",""],[9,"decode","","",42],[6,"Encodable","",""],[9,"encode","","",43],[6,"DecoderHelpers","",""],[9,"read_to_vec","","",44],[6,"EncoderHelpers","",""],[9,"emit_from_vec","","",45]],"paths":[[1,"String"],[1,"Box"],[1,"Rc"],[1,"Vec"],[2,"Option"],[1,"Path"],[1,"Path"],[1,"Cell"],[1,"RefCell"],[1,"Arc"],[1,"DList"],[1,"RingBuf"],[1,"BTreeMap"],[1,"BTreeSet"],[1,"EnumSet"],[1,"HashMap"],[1,"HashSet"],[1,"VecMap"],[1,"Config"],[2,"CharacterSet"],[2,"Newline"],[2,"FromBase64Error"],[6,"ToBase64"],[6,"FromBase64"],[2,"FromHexError"],[6,"ToHex"],[6,"FromHex"],[2,"Json"],[2,"ErrorCode"],[2,"ParserError"],[2,"DecoderError"],[2,"JsonEvent"],[2,"StackElement"],[6,"ToJson"],[1,"Encoder"],[1,"PrettyEncoder"],[1,"Stack"],[1,"Parser"],[1,"Builder"],[1,"Decoder"],[6,"Decoder"],[6,"Encoder"],[6,"Decodable"],[6,"Encodable"],[6,"DecoderHelpers"],[6,"EncoderHelpers"]]};

initSearch(searchIndex);
